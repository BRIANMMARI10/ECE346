# Lab 0 
In this lab, we will write a basic ROS package that controls the robot with a keyboard. In addition, we will also implement another ROS node that subscribes to the robot Pose from SLAM, and plots the robot trajectory.  

Please refer to the [lab0.pdf](lab0.pdf) for details. 

# Get Started
## How to build
Even if you have not filled in any code for this lab, you can still build the packages and check what functionalities we have provided for you.

- Open a terminal under to the ```ROS_ws``` and type.

    ```bash
    catkin_make 
    ```
- After the system build successfully, you will need to read and execute setups for your build by 
    ```bash
    source devel/setup.bash
    ```
## How to run your package
We have prepared [launchfiles](ROS_ws/src/lab0/launch) for this lab. Checkout this [tutorial](http://wiki.ros.org/ROS/Tutorials/UsingRqtconsoleRoslaunch#Using_roslaunch) for more information. Under the same terminal that you build this package, use the command
```bash
roslaunch ece346_lab0 FILENAME.launch
```
For example, if you just want to launch the node for keyboard control that we have provided, you can 
```
roslaunch ece346_lab0 keyboard_only.launch
```
If everything is executed correctly, you will see the following ![keyboard](/asset/Figures/lab0/keyboard_node.png)

## Checkpoint 4
In this checkpoint, we want to develop a ros network with three nodes.![](/asset/Figures/lab0/checkpoint4_rqt.png)
1. A ```teleop_node``` that we provide will capture your keyboard input and publish a message to ```/cmd_vel``` topic
2. A ```keyboard_listener``` node we will work on will translate that message into a form that will be understood by ```rc_control_node```
3. The provided ```rc_control_node``` receives the message and command the low-level controller.

More specifically, The ```keyboard_listener``` node are defined in [keyboard_listener.py](/ROS_ws/src/lab0/scripts/keyboard_listener.py)
1. The node will subscribe to ```geometric_msg/Twist``` messages sent through ```/cmd_vel``` topic
2. In the subscriber's callback function, we extract the ```linear.x``` as the throttle input and ```angular.z``` as the steering input to Construct a ```rc_control_msgs/RCControl``` message
3.  Publish the message with topic ```/control/servo_control``` inside the callback function of the subscriber

### Inspect the message structure
You may want to inspect what is the structure of the message, this can be done easyly through 
```bash
 rosmsg show MSG_NAME
 ```
 If you are doing this in a new terminal window, **always** ```source devel/setup.bash``` first.

For example, if you want to see what is the structre of ```rc_control_msgs/RCControl``` message, ![](/asset/Figures/lab0/rosmsg_show.png)

Once you are done, you can run 
```bash 
roslaunch ece346_lab0 checkpoint1.launch
```
to test your code. Always make sure that you lift the car by placing a box under the chassis test.

## Checkpoint 5
In this checkpoint, we will write a simple ROS node in [pose_node.py](/ROS_ws/src/lab0/scripts/pose_node.py) to visualize the trajectory generated by ZED camera's SLAM system. The estimated pose from ZED camera is published under the topic ```/zed2/zed_node/pose```

### Hints
Without coding up, you can still launch the ZED cameraâ€™s node first and inspect the pose message by
```bash 
roslaunch ece346_lab0 checkpoint2.launch
```
In this case, you will see blank plot. However, the ZED node is running properly, and you can use ROS's useful [```rostopic```](http://wiki.ros.org/rostopic) tools to inspect messages published by ZED node. For example, if we are not sure what type of message that  ```/zed2/zed_node/pose``` topic is, we can do 
```bash
rostopic type /zed2/zed_node/pose
```


